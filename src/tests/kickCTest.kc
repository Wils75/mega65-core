import "c64.kc"
import "print"

//byte* ZERO = $2000;

void POKE(unsigned short address, unsigned char value)
{
  *(unsigned char*)address = value;
}

unsigned char PEEK(unsigned short address)
{
  return *(unsigned char*)address;
}

//kickasm(resource "invert/000.png", pc ZERO, bytes 6*4*8)
//{{
//    .var zeroPic = LoadPicture("invert/000.png", List().add($444444, $808080, $000000, $ffffff))
//    .for (var y=0; y<6	; y++)
//        .for (var x=0;x<4; x++)
//            .for(var cp=0; cp<8; cp++)
//                .byte zeroPic.getMulticolorByte(x,cp+y*8)
//}}

//unsigned short i;

struct dmagic_dmalist
{
  unsigned char option_0b;
  unsigned char option_80;
  unsigned char source_mb;
  unsigned char option_81;
  unsigned char dest_mb;
  unsigned char end_of_options;

  // F018B format DMA request
  unsigned char command;
  unsigned int count;
  unsigned int source_addr;
  unsigned char source_bank;
  unsigned int dest_addr;
  unsigned char dest_bank;
  unsigned char sub_cmd;  // F018B subcmd
  unsigned int modulo;
};

struct dmagic_dmalist dmalist;
unsigned char dma_byte;

void do_dma(void)
{

  // Now run DMA job (to and from anywhere, and list is in low 1MB)
  POKE(0xd702, 0);
  POKE(0xD704, 0x00);
  POKE(0xd701, ((unsigned char) & dmalist) >> 8);
  POKE(0xd705, ((unsigned char) & dmalist) & 0xff); // triggers enhanced DMA

}

void lpoke(unsigned dword* address, unsigned char value)
{
  unsigned char* charAddress = (unsigned char*) address;
  unsigned word* wordAddress = (unsigned word*) address;

  dmalist.option_0b = 0x0b;       // unsigned char
  dmalist.option_80 = 0x80;       // unsigned char
  dmalist.source_mb = 0;          // unsigned char
  dmalist.option_81 = 0x81;       // unsigned char

  unsigned char char1 = charAddress[0];
  char1 = char1 << 4;
  char1 = char1 & 0xf0;
  unsigned char char2 = charAddress[1];
  char2 = char2 >> 4;
  char2 = char2 & 0x0f;
  dmalist.dest_mb = char1 + char2;// unsigned char

  dmalist.end_of_options = 0x00;  // unsigned char

  dma_byte = value;
  dmalist.command = 0x00; // copy
  dmalist.sub_cmd = 0;
  dmalist.modulo = 0;
  dmalist.count = 1;
  dmalist.source_addr = (unsigned int) &dma_byte;
  dmalist.source_bank = 0;
  dmalist.dest_addr = wordAddress[1];

  char1 = charAddress[1];
  char1 = char1 & 0x0f;

  dmalist.dest_bank = char1;

  do_dma();
  return;
}

unsigned char lpeek(long address)
{
  dmalist.option_0b=0x0b;
  dmalist.option_80=0x80;
  dmalist.source_mb=address>>20;
  dmalist.option_81=0x81;
  dmalist.dest_mb=0;
  dmalist.end_of_options=0x00;

  dmalist.command = 0x00; // copy
  dmalist.count = 1;
  dmalist.source_addr = address&0xffff;
  dmalist.source_bank = (address >> 16)&0x0f;
  dmalist.dest_addr = (unsigned int) &dma_byte;
  dmalist.source_bank = 0;
  dmalist.dest_addr = address&0xffff;
  dmalist.dest_bank = (address >> 16)&0x0f;
  // Make list work on either old or new DMAgic
  dmalist.sub_cmd = 0;
  dmalist.modulo = 0;

  do_dma();
  return dma_byte;
}

void lcopy(long source_address, long destination_address, unsigned int count)
{
  dmalist.option_0b=0x0b;
  dmalist.option_80=0x80;
  dmalist.source_mb=source_address>>20;
  dmalist.option_81=0x81;
  dmalist.dest_mb=destination_address>>20;
  dmalist.end_of_options=0x00;

  dmalist.command = 0x00; // copy
  dmalist.count = count;
  dmalist.sub_cmd = 0;
  dmalist.modulo = 0;
  dmalist.source_addr = source_address&0xffff;
  dmalist.source_bank = (source_address >> 16)&0x0f;
  //  if (source_address >= 0xd000 && source_address < 0xe000)
  //    dmalist.source_bank|=0x80;
  dmalist.dest_addr = destination_address&0xffff;
  dmalist.dest_bank = (destination_address >> 16)&0x0f;
  //  if (destination_address>=0xd000 && destination_address<0xe000)
  //    dmalist.dest_bank|=0x80;

  do_dma();
  return;
}

void lfill(unsigned dword destination_address, unsigned char value, unsigned int count)
{
  unsigned char* charAddress = (unsigned char*) &destination_address;
  unsigned word* wordAddress = (unsigned word*) &destination_address;

  dmalist.option_0b = 0x0b;
  dmalist.option_80 = 0x80;
  dmalist.source_mb = 0;
  dmalist.option_81 = 0x81;

  unsigned char char1 = charAddress[0];
  char1 = char1 << 4;
  unsigned char char2 = charAddress[1];
  char2 = char2 >> 4;

  dmalist.dest_mb = char1 + char2;
  dmalist.end_of_options = 0x00;

  dmalist.command = 0x03; // fill
  dmalist.sub_cmd = 0;
  dmalist.count = count;
  dmalist.source_addr = value;
  dmalist.dest_addr = (unsigned int) wordAddress[1];

  char1 = charAddress[1];
  char1 = char1 & 0x0f;

  dmalist.dest_bank = char1;

  unsigned word tempWord = wordAddress[1];

  if (tempWord >= 0xd000 && tempWord < 0xe000)
    dmalist.dest_bank |= 0x80;

  do_dma();
  return;
}

// Holds serial input temporarily
unsigned char serialInput;

// Delay drawing in the program
unsigned int drawDelay;

// Dummy variable to iterate through digits
unsigned int drawCounter;

// Dummy data for heart visuals
unsigned int heartIterator;

// To efficiently iterate through frames in serial input packets
unsigned char[5] frame;

// Colour of the line being drawn
unsigned char f;

// Mathematical calculations to split up digits
unsigned short char1, char2, char3, divisor;

// Dummy data for the heart visuals
const unsigned int[30] heartData = {49,
                                    50,
                                    53,
                                    58,
                                    65,
                                    74,
                                    65,
                                    58,
                                    53,
                                    50,
                                    49,
                                    48,
                                    45,
                                    40,
                                    33,
                                    24,
                                    33,
                                    40,
                                    45,
                                    48,
                                    49,
                                    50,
                                    52,
                                    53,
                                    57,
                                    61,
                                    57,
                                    53,
                                    52,
                                    50};

// To keep track of frame number in packet
unsigned char fnum = 0;

// Most likely for testing, will always be 1 less than fnum
unsigned char flast = 99;

// Storing extracted health readings from packets
unsigned char spo2;
unsigned short prh;
unsigned short pr;

// Screen location
unsigned short *screen = 0xA000;

// Iteration variables declared
unsigned int x, x1;
unsigned int y, newX, newY;

// Maintaining array positions for each reading
unsigned int heartYPos, pulseYPos, oxyYPos;

// Counter for horizontal lines between readings
unsigned int horizontalCounter;

// Labels for pulseoxy readings
unsigned char* heartString = "  heart  rate  ";
unsigned char* plethString = "     pleth     ";
unsigned char* spo2String = "     spo2%      ";

// Temp variables for bitwise pixel drawing operations
unsigned char c;
unsigned dword a;

// Pixel management for each pulseoxy reading
unsigned dword heartRatePixel, plethPixel,spo2Pixel;

// Pixel storage for each pulseoxy reading
const unsigned dword[478] heartRatePixelArray;
const unsigned dword[478] plethPixelArray;
const unsigned dword[478] spo2PixelArray;

// Temp variable for screen RAM initialisation
unsigned word n = 0;

// Function for plotting pixels
void plot_pixel()
{
  // Integer halving the number with bitwise shift
  x1 = x>>1;

  // Pixel memory address location
  a = 0x40000 +
  // Bitwise AND with 7 to keep resulting value below 4 bits
  (x1&7) +
  // Multiply y with unsigned int 8 because of character size
  (y*8) +
  // Bitwise shift by 3 (long)
  (x1>>3) *
  // Screen dimension multiplication
  (50*64);

  // Plotting heart rate pixels
  heartRatePixel = 0x40000 +
  (x1&7) +
  (heartYPos*8) +
  (x1>>3) *
  (50*64);

  // Plotting pleth pixels
  plethPixel = 0x40000 +
  (x1&7) +
  (pulseYPos*8) +
  (x1>>3) *
  (50*64);

  // Plotting spo2 pixels
  spo2Pixel = 0x40000 +
  (x1&7) +
  (oxyYPos*8) +
  (x1>>3) *
  (50*64);

  // Assign serialInput to 0
  serialInput = 0;

  // Replacement for modulus (runs statement if odd)
  if (!(x&1)) {
    serialInput &= 0xf0;
    serialInput |= c;
  }
  // Else runs if even
  else {
    serialInput &= 0xf;
    serialInput |= (c<<4);
  }
}

// Function to draw visualised readings
void drawRateLines()
{
  // Set current pixels to empty (for each reading)
  lpoke(heartRatePixelArray[x], 0x00);
  lpoke(plethPixelArray[x], 0x00);
  lpoke(spo2PixelArray[x], 0x00);

  // Dummy array plotting for heart rate reading
  if (heartIterator < 29)
  {
    heartYPos = heartData[heartIterator];
    heartIterator += 1;
  }
  else
  {
    heartIterator = 0;
    heartYPos = heartData[heartIterator];
  }

  // Reading/interpreting serial input for pulse
  serialInput = PEEK(0xd012);
  pulseYPos = (serialInput/4) +  124;

  // Setting heart rate visuals with chosen colour
  unsigned char lineColour = 0x22;
  lpoke(heartRatePixel, lineColour);
  heartRatePixelArray[x] = heartRatePixel;

  // Setting pleth visuals with chosen colour
  lineColour = 0x33;
  lpoke(plethPixel, lineColour);
  plethPixelArray[x] = plethPixel;

  // Setting spo2 visuals with chosen colour
  lineColour = 0x55;
  lpoke(spo2Pixel, lineColour);
  spo2PixelArray[x] = spo2Pixel;
}

// Function to draw horizontal lines between visual readings
void drawHorizontalLines()
{
  // Initialise counter of horizontal lines for while loop
  horizontalCounter = 0;

  // While the three horizontal lines haven't been drawn
  while (horizontalCounter < 3)
  {
    // Plot pixels to create yellow lines between readings
    plot_pixel();
    lpoke(a, 0x77);

    // Ensuring that all three lines are drawn
    if (y == 99 || y == 198)
    {
      y += 99;
    }
    else
    {
      y = 99;
    }

    // Incrementing the counter for the three lines
    horizontalCounter += 1;
  }
}

void drawDigits(unsigned short number,
                unsigned short offsetX,
                unsigned short offsetY)
{
  for(newX = (30 + offsetX); newX < (33 + offsetX); ++newX)
  {
    for(newY = offsetY; newY < (5 + offsetY); ++newY)
    {
      screen[newX + newY * 45] = 102;
    }
  }

  newX = 30 + offsetX;
  newY = (1 + offsetY);
}

void main(void)
{

  // Fast CPU
  POKE(0, 65);

  // Enable access to serial port and other devices
  POKE(53295, 0x47);
  POKE(53295, 0x53);

  // Set serial port speed to 9600
  POKE(0xd0e6, 0x46);
  POKE(0xd0e7, 0x10);

  // High res in X and Y directions
  POKE(0xD031, 0x88);

  // Accessing the VIC registers
  POKE(0xd02f, 0x47);
  POKE(0xd02f, 0x53);

  // Setting 16 bit character mode
  // also enable full colour chars for chars >$FF
  POKE(0xd054, 0x05);

  // Move screen to $A000
  POKE(0xD060, 0x00);
  POKE(0xD061, 0xA0);

  // Logical lines are 90 bytes long
  POKE(0xD058, 90);
  POKE(0xD05E, 45);

  // Make screen background black
  POKE(0xD020, 0);
  POKE(0xD021, 0);

  // Clear colour RAM and set correct bits for showing full colour chars
  lfill(0xff80000, 0x08, 45 * 50 * 2);

  n = 0x1000;
  lfill((unsigned dword) screen, 0, 45 * 50 * 2);

  for(x = 0; x < 30; x++)
  {

    for(y = 0; y < 50; y++)
    {

      screen[x + (y * 45)] = n;
      ++n;
      n = n & 0x1fff;

    }

  }

  // Initialising checkered area for digits
  for(x = 30; x < 45; ++x)
  {

    for(y = 0; y < 50; ++y)
    {

      screen[x + (y * 45)] = 102;

      dword* addressPointer1 = 0xff80000 + ((dword) x * 2) + ((dword) y * 90) + 0;
      dword* addressPointer2 = 0xff80000 + ((dword) x * 2) + ((dword) y * 90) + 1;

      lpoke(addressPointer1, 0);
      lpoke(addressPointer2, 1);

    }

  }

}
