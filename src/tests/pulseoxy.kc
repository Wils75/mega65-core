import "c64.kc"
import "print"                       

import "megaPhoneDiallerElements"

// Screen location
unsigned short *screen = 0xA000;
unsigned byte *scr = 0xa000;
unsigned int x, y;
unsigned int n = 0;

inline void POKE(const unsigned int address, const unsigned char value)
{
  *(unsigned char*) address = value;
}

inline unsigned char PEEK(const unsigned word address)
{
  return *(unsigned char*) address;
}

struct dMagicDMAList
{
  unsigned char option_0b;
  unsigned char option_80;
  unsigned char source_mb;
  unsigned char option_81;
  unsigned char dest_mb;
  unsigned char end_of_options;

  // F018B format DMA request
  unsigned char command;
  unsigned int count;
  unsigned int source_addr;
  unsigned char source_bank;
  unsigned int dest_addr;
  unsigned char dest_bank;
  unsigned char sub_cmd;  // F018B subcmd
  unsigned int modulo;
};

struct dMagicDMAList[1] dmaList;
unsigned char dmaByte;

void doDMA()
{
  POKE(0xd702, 0x00);
  POKE(0xd704, 0x00);
  POKE(0xd701, (unsigned char) (>(unsigned char*) &dmaList[0]));
  POKE(0xd705, (unsigned char) (<(unsigned char*) &dmaList[0]));
}

inline void lpoke(unsigned long address, unsigned char value)
{
  unsigned char* charPointer = (unsigned char*) &address;
  unsigned int* intPointer = (unsigned int*) &address;

	// *(unsigned char *)$0426=<&dmaList;
  //*(unsigned char *)$0427=>&dmaList;

  // Smoosh two nibbles into one byte and assign
  unsigned char mega_byte = (charPointer[3] << 4) | (charPointer[2] >> 4);

  dmaList[0].option_0b = 0x0b;         // Unsigned char
  dmaList[0].option_80 = 0x80;         // Unsigned char
  dmaList[0].source_mb = 0;            // Unsigned char
  dmaList[0].option_81 = 0x81;         // Unsigned char
  dmaList[0].end_of_options = 0x00;

  dmaList[0].command = 0x00;
  dmaList[0].sub_cmd = 0;
  dmaList[0].modulo = 0;
  dmaList[0].count = 1;
  dmaList[0].source_bank = 0;

  dmaList[0].dest_addr = (intPointer[0]);
  dmaList[0].dest_bank = (charPointer[2] & 0x0f);

  dmaList[0].dest_mb = mega_byte;         // Unsigned char
  dmaByte = value;

  dmaList[0].source_addr = (unsigned int) &dmaByte;
  doDMA();
}

inline void lfill(unsigned long address, unsigned char value, unsigned int count)
{
  unsigned char* charPointer = (unsigned char*) &address;
  unsigned int* intPointer = (unsigned int*) &address;

  dmaList[0].option_0b = 0x0b;         // Unsigned char
  dmaList[0].option_80 = 0x80;         // Unsigned char
  dmaList[0].source_mb = 0;            // Unsigned char
  dmaList[0].option_81 = 0x81;         // Unsigned char

  // Smoosh two nibbles into one byte and assign
  unsigned char short1 = charPointer[3];
  unsigned char short2 = charPointer[2];
  short1 = short1 << 4;
  short2 = short2 >> 4;
  unsigned char short3 = short1 | short2;
  dmaList[0].dest_mb = short3;         // Unsigned char

  dmaList[0].end_of_options = 0x00;
  dmaList[0].command = 0x03;
  dmaList[0].sub_cmd = 0;
  dmaList[0].count = count;
  dmaList[0].source_addr = value;

  unsigned int int1 = (unsigned int) intPointer[0];
  dmaList[0].dest_addr = int1;

  short1 = charPointer[2];
  short1 = short1 & 0x0f;

  dmaList[0].dest_bank = short1;

  short1 = charPointer[1];

  if (short1 >= (unsigned char) 0xd0 && short1 < (unsigned char) 0xe0)
  {
    dmaList[0].dest_bank |= 0x80;
  }

  doDMA();

}

void main(void)
{		
  // Fast CPU
  POKE(0, 65);

  // Enable access to serial port and other devices
  POKE(53295,0x47);
  POKE(53295,0x53);

  // High res in X and Y directions
  POKE(0xd031, 0x88);

  // Set serial port speed to 9600
  POKE(0xd0e6, 0x46);
  POKE(0xd0e7, 0x10);

  // Accessing the VIC registers
  POKE(0xd02f, 0x47);
  POKE(0xd02f, 0x53);

  // Setting 16 bit character mode
  // also enable full colour chars for chars >$FF
  POKE(0xd054, 0x05);

  // Move screen to $A000
  POKE(0xD060, 0x00);
  POKE(0xD061, 0xa0);

  // Logical lines are 90 bytes long
  POKE(0xD058, 0x5a);
  POKE(0xD05E, 0x2d);

  // Make screen background black
  POKE(0xD020, 0x00);
  POKE(0xD021, 0x00);

  // Clear colour RAM and set correct bits for showing full colour chars
  lfill(0x0ff80000, 0x08, 90 * 50);

  // Initialise the screen RAM
  n = 0x1000;

  for(x = 0; x < 45; x++)
  {
		for(y = 0; y < 50; y++)
		{
			screen[x + (y * 45)] = n;
			n++;
			n &= 0x1fff;
		}
  }

	for(x = 30; x < 45; x++)
	{
		for(y = 0; y < 50; y++)
		{
			screen[x + (y * 45)] = 102;
			unsigned int xi = x * 2;
			unsigned long xl = (unsigned long) xi;
			unsigned int yi = y * 90;
			unsigned long yl = (unsigned long) yi;
			unsigned long p1 = 0x0ff80000 + xl + yl;
			unsigned long p2 = p1 + 1;

			lpoke(p1, 0x00);
			lpoke(p2, 0x01);			
		}
	}

	unsigned short ch = ((unsigned word) aByte) >> 6;
	unsigned short c1 = ((unsigned word) bByte) >> 6;
 
	*screen = ch;
	*(screen + 45) = c1;

	while(1)
	{
		//		(*(scr + 999))++;
		//		kickasm{{inc $d020}}
	}
}
